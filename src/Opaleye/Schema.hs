{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE Arrows #-}

module Opaleye.Schema where

import Data.Profunctor.Product.Default as D
import Data.Profunctor.Product as PP
import Data.Profunctor
import Control.Applicative
import Opaleye.Internal.Table as IT
import qualified Opaleye.Internal.TableMaker as TM
import Opaleye.Internal.PackMap as PM
import Opaleye.Internal.Column as IC
import Opaleye.Table as T
import Opaleye.PGTypes as PG
import Opaleye as O
import Control.Arrow

data TableSchema = TableSchema String [TM.ColumnDescription]

tableSchema :: forall read write. 
  (D.Default SchemaMaker read write) =>
  IT.Table write read -> TableSchema
tableSchema (IT.Table tableName (IT.TableProperties _ (View tableColumns))) = 
  TableSchema tableName columns
  where
  s :: SchemaMaker read write
  s = def
  SchemaMaker (PM.PackMap pm) = s
  extractor d = ([d], ())
  (columns, ()) = pm extractor tableColumns
  
data ForeignKey = ForeignKey [String] [String]

foreignKey ::
  forall from from' to to' fk.
  (D.Default SchemaMaker fk fk) =>
  IT.Table from' from -> (from -> fk) -> IT.Table to' to -> (to -> fk) -> ForeignKey
foreignKey tableFrom selectSubsetFrom tableTo selectSubsetTo = let
  extractor (TM.ColumnDescription name _ _) = ([name], ())
  (Table _ (TableProperties _ (View tableColsFrom))) = tableFrom
  (Table _ (TableProperties _ (View tableColsTo))) = tableTo
  keyFrom = selectSubsetFrom tableColsFrom
  keyTo = selectSubsetTo tableColsTo
  s1 :: SchemaMaker fk fk
  s1 = def
  (SchemaMaker (PM.PackMap pm)) = s1
  (columnsFrom, ()) = pm extractor keyFrom
  (columnsTo, ()) = pm extractor keyTo
  in ForeignKey columnsFrom columnsTo

columnSchemaMaker :: SchemaMaker (TM.TableColumn a) b
columnSchemaMaker = SchemaMaker (PM.PackMap (\f (TM.TableColumn c) -> f c))

instance D.Default SchemaMaker (TM.TableColumn a) (Column a) where
  def = columnSchemaMaker

instance D.Default SchemaMaker (TM.TableColumn a) (TM.TableColumn a) where
  def = columnSchemaMaker

instance D.Default SchemaMaker (TM.TableColumn a) (Maybe (Column a)) where
  def = columnSchemaMaker


newtype SchemaMaker read dummy =
  SchemaMaker (PM.PackMap TM.ColumnDescription () read ())

instance Functor (SchemaMaker a) where
  fmap _ (SchemaMaker g) = SchemaMaker (g)

instance Applicative (SchemaMaker a) where
  pure x = SchemaMaker (fmap (const ()) (pure x))
  SchemaMaker fx <*> SchemaMaker x = SchemaMaker $
    pure (const id) <*> fx <*> x

instance Profunctor SchemaMaker where
  dimap f _ (SchemaMaker q) = SchemaMaker (lmap f q)

instance ProductProfunctor SchemaMaker where
  empty = PP.defaultEmpty
  (***!) = PP.defaultProfunctorProduct



type T1 = (Maybe (Column PGInt8), Column PGInt8)
type T1' = (TM.TableColumn PGInt8, TM.TableColumn PGInt8)
type T1'' = (Column PGInt8, Column PGInt8)

t1 :: Table T1 T1'
t1 = Table "t1" $ p2 (T.optional "col0" Autogenerated, T.required "col1" NoIntOptions)

t1ForeignKey :: ForeignKey
t1ForeignKey = foreignKey t1 fst t1 snd

t1Schema :: TableSchema
t1Schema = tableSchema t1

{-
query :: O.Query T1
query = proc () -> do
  (col1, col2) <- T.queryTable t1 -< ()
  returnA -< col1
-}

t1Query :: O.Query T1''
t1Query = T.queryTable t1

query' :: O.Query (Column PGInt8)
query' = proc () -> do
  (col1, _) <- t1Query -< ()
  returnA -< col1


